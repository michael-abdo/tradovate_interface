diff --git a/scripts/tampermonkey/autoOrder.user.js b/scripts/tampermonkey/autoOrder.user.js
index 47d9bd5..cca0def 100644
--- a/scripts/tampermonkey/autoOrder.user.js
+++ b/scripts/tampermonkey/autoOrder.user.js
@@ -21,6 +21,53 @@
         return new Promise(resolve => setTimeout(resolve, ms));
     }
 
+    // Scale-in utility functions
+    function updateQuantitySplit() {
+        const quantitySplitDiv = document.getElementById('quantitySplit');
+        if (!quantitySplitDiv) return;
+        
+        const scaleEnabled = document.getElementById('scaleInCheckbox')?.checked;
+        if (!scaleEnabled) {
+            quantitySplitDiv.textContent = '';
+            return;
+        }
+        
+        const quantity = parseInt(document.getElementById('qtyInput')?.value || '0');
+        const levels = parseInt(document.getElementById('scaleLevelsInput')?.value || '4');
+        
+        if (quantity > 0 && levels > 0) {
+            const qtyPerLevel = quantity / levels;
+            quantitySplitDiv.textContent = `${quantity} √∑ ${levels} = ${qtyPerLevel.toFixed(1)} per level`;
+        } else {
+            quantitySplitDiv.textContent = '';
+        }
+    }
+    
+    function updateTickValue() {
+        const tickValueDiv = document.getElementById('tickValue');
+        if (!tickValueDiv) return;
+        
+        const scaleEnabled = document.getElementById('scaleInCheckbox')?.checked;
+        if (!scaleEnabled) {
+            tickValueDiv.textContent = '';
+            return;
+        }
+        
+        const spacing = parseInt(document.getElementById('scaleSpacingInput')?.value || '0');
+        const symbol = document.getElementById('symbolInput')?.value || 'NQ';
+        
+        // Get tick value from futuresTickData or default values
+        const tickData = window.futuresTickData[symbol] || { tickValue: 5.0 };
+        const tickValue = tickData.tickValue || 5.0;
+        const dollarValue = spacing * tickValue;
+        
+        if (spacing > 0) {
+            tickValueDiv.textContent = `${spacing} ticks = $${dollarValue.toFixed(2)} for ${symbol}`;
+        } else {
+            tickValueDiv.textContent = '';
+        }
+    }
+
     function createUI(visible = false) {
         console.log(`Creating UI (visible=${visible})`);
         const storedTP   = localStorage.getItem('bracketTrade_tp')  || '53';
@@ -28,6 +75,9 @@
         const storedQty  = localStorage.getItem('bracketTrade_qty') || '10';
         const storedTick = localStorage.getItem('bracketTrade_tick')|| '0.25';
         const storedSym  = localStorage.getItem('bracketTrade_symbol') || 'NQ';
+        const storedScaleEnabled = localStorage.getItem('bracketTrade_scaleEnabled') === 'true';
+        const storedScaleLevels = localStorage.getItem('bracketTrade_scaleLevels') || '4';
+        const storedScaleSpacing = localStorage.getItem('bracketTrade_scaleSpacing') || '20';
         console.log(`Stored values: TP=${storedTP}, SL=${storedSL}, Qty=${storedQty}, Tick=${storedTick}, Symbol=${storedSym}`);
 
         const container = document.createElement('div');
@@ -120,6 +170,31 @@
                     </div>
                     <button id="sellBtn" style="padding:6px 10px;background:#e74c3c;color:#fff;border:none;border-radius:4px;font-weight:bold;">Sell</button>
                 </div>
+                
+                <!-- Scale In Controls -->
+                <div style="margin-bottom:12px;border-top:1px solid #444;padding-top:8px;">
+                    <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
+                        <input type="checkbox" id="scaleInCheckbox" ${storedScaleEnabled ? 'checked' : ''}
+                            style="cursor:pointer;" />
+                        <label for="scaleInCheckbox" style="font-size:12px;cursor:pointer;">Scale In</label>
+                        <div id="quantitySplit" style="font-size:10px;color:#999;margin-left:auto;"></div>
+                    </div>
+                    <div id="scaleControls" style="display:${storedScaleEnabled ? 'block' : 'none'};">
+                        <div style="display:flex;gap:4px;margin-bottom:4px;">
+                            <div style="flex:1;">
+                                <label style="display:block;font-size:10px;color:#999;margin-bottom:2px;">Levels</label>
+                                <input type="number" id="scaleLevelsInput" value="${storedScaleLevels}" min="1" max="8"
+                                    style="width:100%;text-align:center;border-radius:4px;border:1px solid #666;background:#2a2a2a;color:#fff;font-size:12px;" />
+                            </div>
+                            <div style="flex:1;">
+                                <label style="display:block;font-size:10px;color:#999;margin-bottom:2px;">Spacing</label>
+                                <input type="number" id="scaleSpacingInput" value="${storedScaleSpacing}" min="1"
+                                    style="width:100%;text-align:center;border-radius:4px;border:1px solid #666;background:#2a2a2a;color:#fff;font-size:12px;" />
+                            </div>
+                        </div>
+                        <div id="tickValue" style="font-size:10px;color:#999;text-align:center;"></div>
+                    </div>
+                </div>
                 <div style="display:flex;gap:10px;margin-bottom:2px;">
                     <button id="cancelAllBtn" style="flex:1;padding:12px 8px;background:#e6b800;color:#000;border:none;border-radius:4px;font-weight:bold;">Cancel</button>
                     <button id="closeAllBtn" style="flex:3;padding:12px 8px;background:#e74c3c;color:#fff;border:none;border-radius:4px;font-weight:bold;">Close All</button>
@@ -145,6 +220,12 @@
                 <input type="number" id="slPriceInput" />
                 <input type="checkbox" id="tpCheckbox" checked />
                 <input type="checkbox" id="slCheckbox" checked />
+                <input type="checkbox" id="scaleInCheckbox" ${storedScaleEnabled ? 'checked' : ''} />
+                <input type="number" id="scaleLevelsInput" value="${storedScaleLevels}" />
+                <input type="number" id="scaleSpacingInput" value="${storedScaleSpacing}" />
+                <div id="scaleControls"></div>
+                <div id="quantitySplit"></div>
+                <div id="tickValue"></div>
             `;
         }
 
@@ -181,6 +262,31 @@
         document.getElementById('qtyInput').addEventListener('input', e => {
             console.log(`Quantity input changed to: ${e.target.value}`);
             localStorage.setItem('bracketTrade_qty', e.target.value);
+            updateQuantitySplit(); // Update scale quantity display
+        });
+        
+        // Scale In Controls Event Handlers
+        document.getElementById('scaleInCheckbox').addEventListener('change', e => {
+            console.log(`Scale In checkbox changed to: ${e.target.checked}`);
+            localStorage.setItem('bracketTrade_scaleEnabled', e.target.checked);
+            
+            const scaleControls = document.getElementById('scaleControls');
+            if (scaleControls) {
+                scaleControls.style.display = e.target.checked ? 'block' : 'none';
+            }
+            updateQuantitySplit();
+        });
+        
+        document.getElementById('scaleLevelsInput').addEventListener('input', e => {
+            console.log(`Scale levels input changed to: ${e.target.value}`);
+            localStorage.setItem('bracketTrade_scaleLevels', e.target.value);
+            updateQuantitySplit();
+        });
+        
+        document.getElementById('scaleSpacingInput').addEventListener('input', e => {
+            console.log(`Scale spacing input changed to: ${e.target.value}`);
+            localStorage.setItem('bracketTrade_scaleSpacing', e.target.value);
+            updateTickValue();
         });
         document.getElementById('closeAllBtn').addEventListener('click', () => {
             console.log('Close All button clicked');
@@ -274,7 +380,7 @@
 
             // Update TP and SL based on the symbol's default values
             const rootSymbol = symbolValue.replace(/[A-Z]\d+$/, '');
-            const symbolDefaults = futuresTickData[rootSymbol];
+            const symbolDefaults = window.futuresTickData[rootSymbol];
 
             if (symbolDefaults) {
                 console.log(`Found default values for ${rootSymbol}: SL=${symbolDefaults.defaultSL}, TP=${symbolDefaults.defaultTP}`);
@@ -299,12 +405,36 @@
                 localStorage.setItem('bracketTrade_tp', symbolDefaults.defaultTP);
 
                 console.log(`Updated SL/TP to default values for ${rootSymbol}: SL=${slInput.value}, TP=${tpInput.value}`);
+                
+                // Update scale-in defaults for the selected symbol
+                const scaleLevelsInput = document.getElementById('scaleLevelsInput');
+                const scaleSpacingInput = document.getElementById('scaleSpacingInput');
+                
+                if (scaleLevelsInput && scaleSpacingInput) {
+                    // Get scale defaults from symbol configuration
+                    const scaleInLevels = symbolDefaults.scale_in_levels || 4;
+                    const scaleInTicks = symbolDefaults.scale_in_ticks || 20;
+                    
+                    // Update the input fields
+                    scaleLevelsInput.value = scaleInLevels;
+                    scaleSpacingInput.value = scaleInTicks;
+                    
+                    // Save to localStorage
+                    localStorage.setItem('bracketTrade_scaleLevels', scaleInLevels);
+                    localStorage.setItem('bracketTrade_scaleSpacing', scaleInTicks);
+                    
+                    console.log(`Updated scale defaults for ${rootSymbol}: Levels=${scaleInLevels}, Spacing=${scaleInTicks}`);
+                    
+                    // Update displays
+                    updateQuantitySplit();
+                    updateTickValue();
+                }
             }
 
             // Update the symbol in Tradovate's interface
             // FIXED: Use more specific selector for order ticket instead of market analyzer
             // Old selector '.search-box--input' was too generic and hit market analyzer first
-            updateSymbol('.trading-ticket .search-box--input', normalizedSymbol);
+            updateSymbol('.trading-ticket.module-placement.width-1-3 .search-box--input', normalizedSymbol);
         });
 
         document.getElementById('tickInput').value = localStorage.getItem('bracketTrade_tick') || '0.25';
@@ -347,39 +477,162 @@
             container.style.cursor = 'grab';
         });
 
+        // Initialize scale displays on UI creation
+        console.log('Initializing scale displays');
+        updateQuantitySplit();
+        updateTickValue();
+
         // Trade buttons
         console.log('Setting up trade buttons');
         document.getElementById('buyBtn').addEventListener('click', () => {
-            console.log('BUY button clicked');
+            console.log('[BUTTON] üü¢ ========== BUY BUTTON CLICKED ==========');
+            console.log('[BUTTON] üìç STEP 1: Button click event triggered');
+            
+            // Gather all input values with detailed logging
             const symbol = document.getElementById('symbolInput').value || 'NQ';
             const qty = +qtyInput.value;
             const tp = +tpInput.value;
             const sl = +slInput.value;
             const tickSize = +document.getElementById('tickInput').value;
-            console.log(`Initiating BUY order: Symbol=${symbol}, Qty=${qty}, TP=${tp}, SL=${sl}, TickSize=${tickSize}`);
-            autoTrade(symbol, qty, 'Buy', tp, sl, tickSize).finally(() => {
-                // Reset price inputs after order is placed
-                document.getElementById('entryPriceInput').value = '';
-                document.getElementById('tpPriceInput').value = '';
-                document.getElementById('slPriceInput').value = '';
-                console.log('Price inputs reset after BUY order');
-            });
+            const entryPrice = document.getElementById('entryPriceInput').value;
+            const scaleEnabled = document.getElementById('scaleInCheckbox')?.checked;
+            
+            console.log('[BUTTON] üìç STEP 2: Input values gathered:');
+            console.log(`[BUTTON]   Symbol: "${symbol}"`);
+            console.log(`[BUTTON]   Quantity: ${qty} (type: ${typeof qty})`);
+            console.log(`[BUTTON]   Take Profit: ${tp} ticks (type: ${typeof tp})`);
+            console.log(`[BUTTON]   Stop Loss: ${sl} ticks (type: ${typeof sl})`);
+            console.log(`[BUTTON]   Tick Size: ${tickSize} (type: ${typeof tickSize})`);
+            console.log(`[BUTTON]   Entry Price: "${entryPrice}" (${entryPrice ? 'LIMIT/STOP ORDER' : 'MARKET ORDER'})`);
+            console.log(`[BUTTON]   Scale-In Enabled: ${scaleEnabled}`);
+            
+            // Validate inputs before proceeding
+            console.log('[BUTTON] üìç STEP 3: Validating inputs...');
+            if (!symbol || symbol.trim() === '') {
+                console.error('[BUTTON] ‚ùå VALIDATION FAILED: Symbol is empty');
+                alert('Error: Symbol cannot be empty');
+                return;
+            }
+            if (!qty || qty <= 0 || isNaN(qty)) {
+                console.error('[BUTTON] ‚ùå VALIDATION FAILED: Invalid quantity');
+                alert('Error: Quantity must be a positive number');
+                return;
+            }
+            if (!tickSize || tickSize <= 0 || isNaN(tickSize)) {
+                console.error('[BUTTON] ‚ùå VALIDATION FAILED: Invalid tick size');
+                alert('Error: Tick size must be a positive number');
+                return;
+            }
+            console.log('[BUTTON] ‚úÖ VALIDATION PASSED: All inputs are valid');
+            
+            console.log('[BUTTON] üìç STEP 4: Checking scale-in before calling autoTrade...');
+            console.log(`[BUTTON]   Scale-In Enabled: ${scaleEnabled}`);
+            if (scaleEnabled) {
+                const scaleLevels = document.getElementById('scaleLevelsInput')?.value || '4';
+                const scaleSpacing = document.getElementById('scaleSpacingInput')?.value || '20';
+                console.log(`[BUTTON]   Scale Levels: ${scaleLevels}, Scale Spacing: ${scaleSpacing}`);
+            }
+            console.log(`[BUTTON]   Parameters: autoTrade("${symbol}", ${qty}, "Buy", ${tp}, ${sl}, ${tickSize})`);
+            
+            // Call autoTrade and handle the result
+            try {
+                const result = autoTrade(symbol, qty, 'Buy', tp, sl, tickSize);
+                if (result && typeof result.finally === 'function') {
+                    result.finally(() => {
+                        // Reset price inputs after order is placed
+                        document.getElementById('entryPriceInput').value = '';
+                        document.getElementById('tpPriceInput').value = '';
+                        document.getElementById('slPriceInput').value = '';
+                        console.log('[BUTTON] üìç STEP 5: Price inputs reset after BUY order');
+                        console.log('[BUTTON] üü¢ ========== BUY PIPELINE COMPLETE ==========');
+                    });
+                } else {
+                    // Reset inputs immediately if no promise returned
+                    document.getElementById('entryPriceInput').value = '';
+                    document.getElementById('tpPriceInput').value = '';
+                    document.getElementById('slPriceInput').value = '';
+                    console.log('[BUTTON] üìç STEP 5: Price inputs reset after BUY order (synchronous)');
+                    console.log('[BUTTON] üü¢ ========== BUY PIPELINE COMPLETE ==========');
+                }
+            } catch (err) {
+                console.error('[BUTTON] ‚ùå BUY autoTrade threw exception:', err);
+                console.log('[BUTTON] üî¥ ========== BUY PIPELINE FAILED ==========');
+            }
         });
         document.getElementById('sellBtn').addEventListener('click', () => {
-            console.log('SELL button clicked');
+            console.log('[BUTTON] üî¥ ========== SELL BUTTON CLICKED ==========');
+            console.log('[BUTTON] üìç STEP 1: Button click event triggered');
+            
+            // Gather all input values with detailed logging
             const symbol = document.getElementById('symbolInput').value || 'NQ';
             const qty = +qtyInput.value;
             const tp = +tpInput.value;
             const sl = +slInput.value;
             const tickSize = +document.getElementById('tickInput').value;
-            console.log(`Initiating SELL order: Symbol=${symbol}, Qty=${qty}, TP=${tp}, SL=${sl}, TickSize=${tickSize}`);
-            autoTrade(symbol, qty, 'Sell', tp, sl, tickSize).finally(() => {
-                // Reset price inputs after order is placed
-                document.getElementById('entryPriceInput').value = '';
-                document.getElementById('tpPriceInput').value = '';
-                document.getElementById('slPriceInput').value = '';
-                console.log('Price inputs reset after SELL order');
-            });
+            const entryPrice = document.getElementById('entryPriceInput').value;
+            const scaleEnabled = document.getElementById('scaleInCheckbox')?.checked;
+            
+            console.log('[BUTTON] üìç STEP 2: Input values gathered:');
+            console.log(`[BUTTON]   Symbol: "${symbol}"`);
+            console.log(`[BUTTON]   Quantity: ${qty} (type: ${typeof qty})`);
+            console.log(`[BUTTON]   Take Profit: ${tp} ticks (type: ${typeof tp})`);
+            console.log(`[BUTTON]   Stop Loss: ${sl} ticks (type: ${typeof sl})`);
+            console.log(`[BUTTON]   Tick Size: ${tickSize} (type: ${typeof tickSize})`);
+            console.log(`[BUTTON]   Entry Price: "${entryPrice}" (${entryPrice ? 'LIMIT/STOP ORDER' : 'MARKET ORDER'})`);
+            console.log(`[BUTTON]   Scale-In Enabled: ${scaleEnabled}`);
+            
+            // Validate inputs before proceeding
+            console.log('üìç STEP 3: Validating inputs...');
+            if (!symbol || symbol.trim() === '') {
+                console.error('‚ùå VALIDATION FAILED: Symbol is empty');
+                alert('Error: Symbol cannot be empty');
+                return;
+            }
+            if (!qty || qty <= 0 || isNaN(qty)) {
+                console.error('‚ùå VALIDATION FAILED: Invalid quantity');
+                alert('Error: Quantity must be a positive number');
+                return;
+            }
+            if (!tickSize || tickSize <= 0 || isNaN(tickSize)) {
+                console.error('‚ùå VALIDATION FAILED: Invalid tick size');
+                alert('Error: Tick size must be a positive number');
+                return;
+            }
+            console.log('‚úÖ VALIDATION PASSED: All inputs are valid');
+            
+            console.log('[BUTTON] üìç STEP 4: Checking scale-in before calling autoTrade...');
+            console.log(`[BUTTON]   Scale-In Enabled: ${scaleEnabled}`);
+            if (scaleEnabled) {
+                const scaleLevels = document.getElementById('scaleLevelsInput')?.value || '4';
+                const scaleSpacing = document.getElementById('scaleSpacingInput')?.value || '20';
+                console.log(`[BUTTON]   Scale Levels: ${scaleLevels}, Scale Spacing: ${scaleSpacing}`);
+            }
+            console.log(`[BUTTON]   Parameters: autoTrade("${symbol}", ${qty}, "Sell", ${tp}, ${sl}, ${tickSize})`);
+            
+            // Call autoTrade and handle the result
+            try {
+                const result = autoTrade(symbol, qty, 'Sell', tp, sl, tickSize);
+                if (result && typeof result.finally === 'function') {
+                    result.finally(() => {
+                        // Reset price inputs after order is placed
+                        document.getElementById('entryPriceInput').value = '';
+                        document.getElementById('tpPriceInput').value = '';
+                        document.getElementById('slPriceInput').value = '';
+                        console.log('üìç STEP 5: Price inputs reset after SELL order');
+                        console.log('üî¥ ========== SELL PIPELINE COMPLETE ==========');
+                    });
+                } else {
+                    // Reset inputs immediately if no promise returned
+                    document.getElementById('entryPriceInput').value = '';
+                    document.getElementById('tpPriceInput').value = '';
+                    document.getElementById('slPriceInput').value = '';
+                    console.log('üìç STEP 5: Price inputs reset after SELL order (synchronous)');
+                    console.log('üî¥ ========== SELL PIPELINE COMPLETE ==========');
+                }
+            } catch (err) {
+                console.error('‚ùå SELL autoTrade threw exception:', err);
+                console.log('üî¥ ========== SELL PIPELINE FAILED ==========');
+            }
         });
         } // End of visible-only event handlers
         
@@ -550,7 +803,7 @@
         
         // Get tick size for the symbol
         const rootSymbol = symbol.replace(/[A-Z]\d+$/, '');
-        const symbolData = futuresTickData[rootSymbol];
+        const symbolData = window.futuresTickData[rootSymbol];
         const tickSize = symbolData?.tickSize || 0.25;
         
         // Add small buffer (1-2 ticks) to account for commissions
@@ -679,9 +932,18 @@
     }
     
     // Initialize UI (defaults to invisible inputs only - no visible popup)
-    console.log('Creating UI for dashboard trading...');
-    createUI();
-    console.log('UI initialization complete');
+    // Create invisible UI elements for backend functionality
+    console.log('üîß Creating invisible UI elements for backend functionality...');
+    createUI(false); // false = invisible mode
+    console.log('üîß Invisible UI initialization complete');
+    
+    // Verify UI elements were created
+    console.log('üîß Verifying UI elements exist:');
+    console.log(`  symbolInput: ${document.getElementById('symbolInput') ? 'EXISTS' : 'MISSING'}`);
+    console.log(`  qtyInput: ${document.getElementById('qtyInput') ? 'EXISTS' : 'MISSING'}`);
+    console.log(`  tickInput: ${document.getElementById('tickInput') ? 'EXISTS' : 'MISSING'}`);
+    console.log(`  tpInput: ${document.getElementById('tpInput') ? 'EXISTS' : 'MISSING'}`);
+    console.log(`  slInput: ${document.getElementById('slInput') ? 'EXISTS' : 'MISSING'}`);
 
     async function updateSymbol(selector, value) {
             console.log(`updateSymbol called with selector: "${selector}", value: "${value}"`);
@@ -691,6 +953,7 @@
             // If no inputs found with primary selector, try fallback selectors
             if (inputs.length === 0) {
                 const fallbackSelectors = [
+                    '.trading-ticket.module-placement.width-1-3 .search-box--input',  // Specific trading ticket module
                     '.trading-ticket input[type="text"]',  // First text input in trading ticket
                     '.order-entry .search-box--input',      // Order entry search box
                     '.order-ticket .search-box--input',     // Order ticket search box  
@@ -718,6 +981,7 @@
             console.log('Selected input:', input);
             console.log('Input location:', {
                 inTradingTicket: !!input.closest('.trading-ticket'),
+                inSpecificTicketModule: !!input.closest('.trading-ticket.module-placement.width-1-3'),
                 inMarketAnalyzer: !!input.closest('.market-analyzer, .market-watchlist'),
                 parentClasses: input.parentElement?.className,
                 placeholder: input.placeholder
@@ -781,10 +1045,17 @@
 
 
     async function createBracketOrdersManual(tradeData) {
-        console.log('Creating bracket orders with data:', tradeData);
-        const enableTP = document.getElementById('tpCheckbox').checked;
-        const enableSL = document.getElementById('slCheckbox').checked;
-        console.log(`TP enabled: ${enableTP}, SL enabled: ${enableSL}`);
+        console.log(`\nüìã ========== CREATE BRACKET ORDERS MANUAL ==========`);
+        console.log(`üìç BRACKET STEP 1: Function called with trade data:`, tradeData);
+        
+        // CRITICAL FIX: Add null checks for TP/SL checkboxes (may not exist)
+        const tpCheckbox = document.getElementById('tpCheckbox');
+        const slCheckbox = document.getElementById('slCheckbox');
+        const enableTP = tpCheckbox?.checked ?? false; // Default to false if checkbox doesn't exist
+        const enableSL = slCheckbox?.checked ?? false; // Default to false if checkbox doesn't exist
+        console.log(`üìç BRACKET STEP 2: Bracket settings:`);
+        console.log(`  Take Profit enabled: ${enableTP}`);
+        console.log(`  Stop Loss enabled: ${enableSL}`);
 
         // DO NOT UNDER ANY CIRCUMSTANCES UPDATE THIS FUNCTION
         async function updateInputValue(selector, value) {
@@ -835,7 +1106,12 @@
 
         async function setCommonFields() {
             console.log('Setting common order fields');
-            //if (tradeData.symbol) await updateSymbol('.search-box--input', normalizeSymbol(tradeData.symbol));
+            // CRITICAL FIX: Enable symbol update
+            if (tradeData.symbol) {
+                console.log(`üéØ Setting symbol to: ${tradeData.symbol}`);
+                await updateSymbol('.trading-ticket.module-placement.width-1-3 .search-box--input', normalizeSymbol(tradeData.symbol));
+                await delay(500); // Allow symbol to load and stabilize
+            }
             if (tradeData.action) {
                 console.log(`Setting action to: ${tradeData.action}`);
                 const actionLabels = document.querySelectorAll('.radio-group.btn-group label');
@@ -886,59 +1162,208 @@
         }
 
         async function submitOrder(orderType, priceValue) {
+            console.log(`üîß Starting submitOrder for ${orderType} order`);
+            
             await setCommonFields();
 
+            // CRITICAL FIX: Add validation before DOM interactions
             const typeSel = document.querySelector('.group.order-type .select-input div[tabindex]');
-            typeSel?.click();
-            [...document.querySelectorAll('ul.dropdown-menu li')]
-                .find(li => li.textContent.trim() === orderType)
-                ?.click();
+            if (!typeSel) {
+                console.error('‚ùå Order type dropdown not found!');
+                return {
+                    success: false,
+                    error: 'Order type dropdown not found',
+                    orders: [],
+                    symbol: null,
+                    summary: null,
+                    rejectionReason: 'UI validation error',
+                    filledCount: 0,
+                    rejectedCount: 1
+                };
+            }
+            
+            console.log(`üìã Setting order type to: ${orderType}`);
+            typeSel.click();
+            await delay(200); // Allow dropdown to open
+            
+            const orderTypeOption = [...document.querySelectorAll('ul.dropdown-menu li')]
+                .find(li => li.textContent.trim() === orderType);
+            if (!orderTypeOption) {
+                console.error(`‚ùå Order type option '${orderType}' not found!`);
+                return {
+                    success: false,
+                    error: `Order type option '${orderType}' not found`,
+                    orders: [],
+                    symbol: null,
+                    summary: null,
+                    rejectionReason: 'UI validation error',
+                    filledCount: 0,
+                    rejectedCount: 1
+                };
+            }
+            orderTypeOption.click();
 
-            //await delay(400);               // NEW - let Tradovate draw the price box
+            // CRITICAL FIX: Restore delay to let Tradovate draw the price box
+            await delay(500);               // Increased delay for UI stability
 
-            if (priceValue)
+            if (priceValue) {
+                console.log(`üí∞ Setting price to: ${priceValue}`);
                 await updateInputValue('.numeric-input.feedback-wrapper input', priceValue);
+            }
             clickPriceArrow();
 
-            document.querySelector('.btn-group .btn-primary')?.click();
-            await delay(200);
+            // CRITICAL FIX: Validate submit button exists before clicking
+            const submitButton = document.querySelector('.btn-group .btn-primary');
+            if (!submitButton) {
+                console.error('‚ùå Submit button not found!');
+                return {
+                    success: false,
+                    error: 'Submit button not found',
+                    orders: [],
+                    symbol: null,
+                    summary: null,
+                    rejectionReason: 'UI validation error',
+                    filledCount: 0,
+                    rejectedCount: 1
+                };
+            }
+            
+            console.log('üöÄ Clicking submit button...');
+            submitButton.click();
+            await delay(500); // Increased delay after order submission
             console.log(getOrderEvents());
             
+            // CRITICAL FIX: Wait longer for order to appear in history
+            console.log('‚è≥ Waiting for order to appear in history...');
+            await delay(1000); // Additional delay for order processing
+            
             // üîÑ CAPTURE ORDER FEEDBACK BEFORE CLICKING BACK BUTTON
-            await captureOrderFeedback();
+            console.log('üìä Capturing order feedback from submitOrder...');
+            const feedbackResult = await captureOrderFeedback();
+            
+            // Log the feedback capture result
+            if (feedbackResult?.rejectionReason) {
+                console.log(`‚úÖ submitOrder captured REJECTION: ${feedbackResult.rejectionReason}`);
+            } else if (feedbackResult?.success && feedbackResult?.orders?.length > 0) {
+                console.log(`‚úÖ submitOrder captured SUCCESS: ${feedbackResult.orders.length} orders`);
+            } else if (feedbackResult?.error) {
+                console.log(`‚ö†Ô∏è submitOrder captured ERROR: ${feedbackResult.error}`);
+            } else {
+                console.log('‚ö†Ô∏è submitOrder captured UNKNOWN result:', feedbackResult);
+            }
             
             document.querySelector('.icon.icon-back')?.click();
             await delay(200);
+            
+            // Return the captured feedback result
+            return feedbackResult;
         }
 
-        console.log(`Submitting initial ${tradeData.orderType || 'MARKET'} order`);
-        await submitOrder(tradeData.orderType || 'MARKET', tradeData.entryPrice);
+        console.log(`üìç BRACKET STEP 3: Submitting initial ${tradeData.orderType || 'MARKET'} order...`);
+        console.log(`  Order type: ${tradeData.orderType || 'MARKET'}`);
+        console.log(`  Entry price: ${tradeData.entryPrice || 'Market price'}`);
+        console.log(`  Action: ${tradeData.action}`);
+        console.log(`  Quantity: ${tradeData.qty}`);
+        
+        // Capture feedback from the main entry order
+        const mainOrderResult = await submitOrder(tradeData.orderType || 'MARKET', tradeData.entryPrice);
+        console.log(`üìä Main order result:`, mainOrderResult);
+        
+        // Initialize bracket feedback aggregation
+        const bracketFeedback = {
+            success: mainOrderResult?.success || false,
+            orders: mainOrderResult?.orders || [],
+            symbol: mainOrderResult?.symbol || null,
+            summary: mainOrderResult?.summary || null,
+            rejectionReason: mainOrderResult?.rejectionReason || null,
+            filledCount: mainOrderResult?.filledCount || 0,
+            rejectedCount: mainOrderResult?.rejectedCount || 0,
+            error: mainOrderResult?.error || null,
+            mainOrder: mainOrderResult,
+            tpOrder: null,
+            slOrder: null
+        };
+
+        // Check if main order was rejected - if so, don't place TP/SL orders
+        if (mainOrderResult?.rejectionReason || mainOrderResult?.error || !mainOrderResult?.success) {
+            console.log(`‚ùå Main order rejected/failed - skipping TP/SL orders`);
+            console.log(`   Rejection reason: ${mainOrderResult?.rejectionReason || mainOrderResult?.error || 'Unknown'}`);
+            
+            // Return immediately with main order feedback
+            console.log('Bracket order creation complete (main order rejected)');
+            return bracketFeedback;
+        }
+        
+        console.log(`‚úÖ Main order successful - proceeding with TP/SL orders`);
 
         if (tradeData.action === 'Buy') {
             console.log('Flipping action to Sell for TP/SL orders');
             tradeData.action = 'Sell';
             if (enableTP) {
                 console.log(`Creating take profit order at ${tradeData.takeProfit}`);
-                await submitOrder('LIMIT', tradeData.takeProfit);
+                const tpResult = await submitOrder('LIMIT', tradeData.takeProfit);
+                bracketFeedback.tpOrder = tpResult;
+                
+                // Aggregate TP results
+                if (tpResult?.orders?.length) {
+                    bracketFeedback.orders = [...bracketFeedback.orders, ...tpResult.orders];
+                }
+                if (tpResult?.filledCount) bracketFeedback.filledCount += tpResult.filledCount;
+                if (tpResult?.rejectedCount) bracketFeedback.rejectedCount += tpResult.rejectedCount;
             }
             if (enableSL) {
                 console.log(`Creating stop loss order at ${tradeData.stopLoss}`);
-                await submitOrder('STOP', tradeData.stopLoss);
+                const slResult = await submitOrder('STOP', tradeData.stopLoss);
+                bracketFeedback.slOrder = slResult;
+                
+                // Aggregate SL results  
+                if (slResult?.orders?.length) {
+                    bracketFeedback.orders = [...bracketFeedback.orders, ...slResult.orders];
+                }
+                if (slResult?.filledCount) bracketFeedback.filledCount += slResult.filledCount;
+                if (slResult?.rejectedCount) bracketFeedback.rejectedCount += slResult.rejectedCount;
             }
         } else {
             console.log('Flipping action to Buy for TP/SL orders');
             tradeData.action = 'Buy';
             if (enableTP) {
                 console.log(`Creating take profit order at ${tradeData.takeProfit}`);
-                await submitOrder('LIMIT', tradeData.takeProfit);
+                const tpResult = await submitOrder('LIMIT', tradeData.takeProfit);
+                bracketFeedback.tpOrder = tpResult;
+                
+                // Aggregate TP results
+                if (tpResult?.orders?.length) {
+                    bracketFeedback.orders = [...bracketFeedback.orders, ...tpResult.orders];
+                }
+                if (tpResult?.filledCount) bracketFeedback.filledCount += tpResult.filledCount;
+                if (tpResult?.rejectedCount) bracketFeedback.rejectedCount += tpResult.rejectedCount;
             }
             if (enableSL) {
                 console.log(`Creating stop loss order at ${tradeData.stopLoss}`);
-                await submitOrder('STOP', tradeData.stopLoss);
+                const slResult = await submitOrder('STOP', tradeData.stopLoss);
+                bracketFeedback.slOrder = slResult;
+                
+                // Aggregate SL results  
+                if (slResult?.orders?.length) {
+                    bracketFeedback.orders = [...bracketFeedback.orders, ...slResult.orders];
+                }
+                if (slResult?.filledCount) bracketFeedback.filledCount += slResult.filledCount;
+                if (slResult?.rejectedCount) bracketFeedback.rejectedCount += slResult.rejectedCount;
             }
         }
+        
+        // Final aggregated feedback logging
+        console.log('üìä Final bracket feedback aggregation:');
+        console.log(`   Overall success: ${bracketFeedback.success}`);
+        console.log(`   Total orders: ${bracketFeedback.orders.length}`);
+        console.log(`   Filled count: ${bracketFeedback.filledCount}`);
+        console.log(`   Rejected count: ${bracketFeedback.rejectedCount}`);
+        if (bracketFeedback.rejectionReason) {
+            console.log(`   Rejection reason: ${bracketFeedback.rejectionReason}`);
+        }
+        
         console.log('Bracket order creation complete');
-        return Promise.resolve();
+        return bracketFeedback;
     }
 
     // returns an array like [{timestamp,id,event,comment,fillPrice}, ‚Ä¶]
@@ -963,8 +1388,53 @@
       });
     }
 
+    // üîÑ WAIT FOR ORDER FEEDBACK WITH RETRY LOGIC
+    window.waitForOrderFeedback = async function(maxWaitTime = 10000, checkInterval = 500) {
+        console.log(`‚è≥ Waiting for order feedback (max ${maxWaitTime/1000}s)...`);
+        
+        const startTime = Date.now();
+        let lastResult = null;
+        let attempts = 0;
+        
+        while (Date.now() - startTime < maxWaitTime) {
+            attempts++;
+            console.log(`‚è≥ Attempt ${attempts}: Checking for order feedback...`);
+            
+            // Try to capture order feedback
+            const result = await captureOrderFeedback();
+            
+            // If we found order history with events, return it
+            if (result.success && result.orders.length > 0) {
+                console.log(`‚úÖ Order feedback found after ${attempts} attempts`);
+                return result;
+            }
+            
+            // If we found a rejection, return immediately
+            if (result.rejectionReason) {
+                console.log(`‚ùå Order rejected after ${attempts} attempts`);
+                return result;
+            }
+            
+            // Store last result for timeout return
+            lastResult = result;
+            
+            // Wait before next check
+            await delay(checkInterval);
+        }
+        
+        // Timeout reached
+        console.log(`‚è±Ô∏è Timeout reached after ${attempts} attempts (${maxWaitTime/1000}s)`);
+        return lastResult || {
+            success: false,
+            error: 'Timeout waiting for order feedback',
+            orders: [],
+            symbol: null,
+            summary: null
+        };
+    };
+
     // üîÑ CAPTURE TRADOVATE ORDER FEEDBACK SYSTEM
-    async function captureOrderFeedback() {
+    window.captureOrderFeedback = async function() {
         console.log('üîÑ CAPTURING TRADOVATE ORDER FEEDBACK...');
         
         // Wait a moment for order feedback to load
@@ -974,65 +1444,136 @@
         const orderHistoryDiv = document.querySelector('.order-history');
         if (!orderHistoryDiv) {
             console.log('‚ùå Order history div not found - no feedback to capture');
-            return;
+            return {
+                success: false,
+                error: 'Order history not found',
+                orders: [],
+                symbol: null,
+                summary: null
+            };
         }
         
         console.log('‚úÖ Found order history div - capturing feedback...');
         
+        // Initialize result object
+        const result = {
+            success: true,
+            orders: [],
+            symbol: null,
+            summary: null,
+            rejectionReason: null,
+            filledCount: 0,
+            rejectedCount: 0
+        };
+        
         // Extract the trading ticket header information
         const ticketHeader = orderHistoryDiv.querySelector('.trading-ticket-header');
         if (ticketHeader) {
             // Extract symbol info
             const symbolDiv = ticketHeader.querySelector('div[style*="font-size: 160%"]');
-            const symbol = symbolDiv ? symbolDiv.textContent.trim() : 'UNKNOWN';
+            result.symbol = symbolDiv ? symbolDiv.textContent.trim() : 'UNKNOWN';
             
             // Extract order summary
             const orderSummaryDiv = ticketHeader.querySelector('div:last-child');
-            const orderSummary = orderSummaryDiv ? orderSummaryDiv.textContent.trim() : 'No summary';
+            result.summary = orderSummaryDiv ? orderSummaryDiv.textContent.trim() : 'No summary';
             
-            console.log(`üìä ORDER FEEDBACK - Symbol: ${symbol}`);
-            console.log(`üìä ORDER FEEDBACK - Summary: ${orderSummary}`);
+            console.log(`üìä ORDER FEEDBACK - Symbol: ${result.symbol}`);
+            console.log(`üìä ORDER FEEDBACK - Summary: ${result.summary}`);
         }
         
         // Extract detailed order events from the data table
         const orderEvents = getOrderEvents(orderHistoryDiv);
-        console.log(`üìä ORDER FEEDBACK - Events (${orderEvents.length} found):`);
-        
-        orderEvents.forEach((event, index) => {
-            console.log(`üìä EVENT ${index + 1}:`, {
-                timestamp: event.timestamp,
-                id: event.id,
-                event: event.event,
-                comment: event.comment,
-                fillPrice: event.fillPrice
-            });
-        });
-        
-        // Extract the entire order history HTML for complete analysis
-        console.log('üìä ORDER FEEDBACK - Full HTML Structure:');
-        console.log(orderHistoryDiv.outerHTML);
+        result.orders = orderEvents;
+        console.log(`üìä ORDER FEEDBACK - Events (${orderEvents.length} found)`);
         
         // Check for specific rejection reasons or success indicators
         const rejectionText = orderHistoryDiv.textContent;
         if (rejectionText.includes('Rejected')) {
+            result.success = false;
+            result.rejectedCount++;
             console.log('‚ùå ORDER REJECTED - checking rejection reason...');
             if (rejectionText.includes('outside of market hours')) {
+                result.rejectionReason = 'Outside market hours';
                 console.log('‚ùå REJECTION REASON: Order placed outside market hours');
             } else if (rejectionText.includes('Risk')) {
+                result.rejectionReason = 'Risk management violation';
                 console.log('‚ùå REJECTION REASON: Risk management violation');
             } else {
+                result.rejectionReason = 'Unknown rejection';
                 console.log('‚ùå REJECTION REASON: Other - check full feedback above');
             }
         } else if (rejectionText.includes('Risk Passed')) {
             console.log('‚úÖ RISK MANAGEMENT: Order passed risk checks');
         }
         
+        // Count filled orders and detect partial fills
+        const filledOrders = orderEvents.filter(event => 
+            event.event.includes('Fill') || event.event.includes('@')
+        );
+        result.filledCount = filledOrders.length;
+        
+        // Enhanced partial fill detection
+        result.partialFills = [];
+        result.totalFillQuantity = 0;
+        result.isPartiallyFilled = false;
+        
+        for (const order of orderEvents) {
+            // Check for partial fill indicators
+            if (order.event.includes('Fill') || order.event.includes('@')) {
+                const fillInfo = {
+                    event: order.event,
+                    quantity: order.quantity,
+                    price: order.price,
+                    timestamp: order.timestamp,
+                    isPartial: false
+                };
+                
+                // Extract quantity from fill event
+                const quantityMatch = order.quantity.match(/(\d+)/);
+                if (quantityMatch) {
+                    fillInfo.filledQuantity = parseInt(quantityMatch[1]);
+                    result.totalFillQuantity += fillInfo.filledQuantity;
+                }
+                
+                // Check if this is explicitly marked as partial
+                if (order.event.toLowerCase().includes('partial') || 
+                    order.event.toLowerCase().includes('part') ||
+                    order.quantity.toLowerCase().includes('partial')) {
+                    fillInfo.isPartial = true;
+                    result.isPartiallyFilled = true;
+                    console.log(`‚ö†Ô∏è PARTIAL FILL DETECTED: ${order.event} - Qty: ${order.quantity}`);
+                }
+                
+                result.partialFills.push(fillInfo);
+            }
+            
+            // Check for remaining quantity indicators
+            if (order.event.toLowerCase().includes('remaining') ||
+                order.event.toLowerCase().includes('unfilled') ||
+                order.event.toLowerCase().includes('pending')) {
+                result.isPartiallyFilled = true;
+                console.log(`‚ö†Ô∏è PARTIAL FILL INDICATOR: ${order.event}`);
+            }
+        }
+        
+        // Log fill summary
+        if (result.filledCount > 0) {
+            console.log(`‚úÖ Found ${result.filledCount} filled orders (Total qty: ${result.totalFillQuantity})`);
+            if (result.isPartiallyFilled) {
+                console.log(`‚ö†Ô∏è PARTIAL FILLS DETECTED - Some orders may not be completely filled`);
+                result.success = 'partial'; // Change success status for partial fills
+            }
+        }
+        
         console.log('üîÑ ORDER FEEDBACK CAPTURE COMPLETE');
-    }
+        return result;
+    };
 
 
     // Futures tick data dictionary with default SL/TP settings for each instrument
-    const futuresTickData = {
+    // Use window property to avoid redeclaration errors on script reinjection
+    if (!window.futuresTickData) {
+        window.futuresTickData = {
       // Symbol: { tickSize, tickValue, defaultSL (ticks), defaultTP (ticks), precision (decimal places) }
       MNQ: { tickSize: 0.25, tickValue: 0.5,  defaultSL: 15,  defaultTP: 53, precision: 2 },  // Micro E-mini Nasdaq-100
       NQ:  { tickSize: 0.25, tickValue: 5.0,  defaultSL: 15,  defaultTP: 53, precision: 2 },  // E-mini Nasdaq-100
@@ -1042,73 +1583,220 @@
       CL:  { tickSize: 0.01, tickValue: 10.0, defaultSL: 50,  defaultTP: 100, precision: 2 },  // Crude Oil
       GC:  { tickSize: 0.1,  tickValue: 10.0, defaultSL: 15,  defaultTP: 30,  precision: 1 },  // Gold (15 ticks = $150 risk)
       MGC: { tickSize: 0.1,  tickValue: 1.0,  defaultSL: 15,  defaultTP: 30,  precision: 1 }   // Micro Gold
-    };
+        };
+    }
 
-function autoTrade(inputSymbol, quantity = 1, action = 'Buy', takeProfitTicks = null, stopLossTicks = null, _tickSize = 0.25, explicitOrderType = null) {
-        console.log(`autoTrade called with: symbol=${inputSymbol}, qty=${quantity}, action=${action}, TP=${takeProfitTicks}, SL=${stopLossTicks}, tickSize=${_tickSize}, orderType=${explicitOrderType}`);
+// Make function declaration safe for reinjection
+window.autoTrade = async function(inputSymbol, quantity = 1, action = 'Buy', takeProfitTicks = null, stopLossTicks = null, _tickSize = 0.25, explicitOrderType = null, isScaleOrder = false, explicitEntryPrice = null) {
+        console.log(`\n[TRADE] üîµüîµüîµ AUTOTRADE FUNCTION (NOT SCALE) üîµüîµüîµ`);
+        console.log(`\n[TRADE] üöÄ ========== AUTOTRADE FUNCTION ENTRY ==========`);
+        console.log(`[TRADE] üìç AUTOTRADE STEP 1: Function called with parameters:`);
+        console.log(`  inputSymbol: "${inputSymbol}"`);
+        console.log(`  quantity: ${quantity} (type: ${typeof quantity})`);
+        console.log(`  action: "${action}"`);
+        console.log(`  takeProfitTicks: ${takeProfitTicks}`);
+        console.log(`  stopLossTicks: ${stopLossTicks}`);
+        console.log(`  _tickSize: ${_tickSize}`);
+        console.log(`  explicitOrderType: ${explicitOrderType}`);
+        console.log(`  explicitEntryPrice: ${explicitEntryPrice}`);
+
+        console.log(`üìç AUTOTRADE STEP 2: Getting symbol from UI...`);
+        
+        // Declare symbolInput outside the try-catch block
+        let symbolInput = inputSymbol || 'NQ'; // Default fallback
+        
+        try {
+            console.log(`üî¥üî¥üî¥ IMMEDIATE DEBUG: Reached line after STEP 2 üî¥üî¥üî¥`);
+            
+            console.log(`üîç DEBUG: Checking if symbolInput element exists...`);
+            const symbolInputElement = document.getElementById('symbolInput');
+            console.log(`üîç DEBUG: symbolInputElement = ${symbolInputElement}`);
+            
+            if (symbolInputElement && symbolInputElement.value) {
+                symbolInput = symbolInputElement.value;
+                console.log(`  ‚úÖ UI Symbol Input element: FOUND`);
+                console.log(`  UI Symbol value: "${symbolInputElement.value}"`);
+                console.log(`  Final symbol to use: "${symbolInput}" (from UI input field)`);
+            } else {
+                console.log(`  ‚ùå UI Symbol Input element: NOT FOUND or empty`);
+                console.log(`  Final symbol to use: "${symbolInput}" (from function parameter)`);
+            }
+        } catch (error) {
+            console.error(`üö® ERROR in STEP 2: ${error.message}`);
+            console.error(`üö® ERROR stack: ${error.stack}`);
+            // symbolInput already has fallback value
+            console.log(`üö® Using fallback symbol: "${symbolInput}"`);
+        }
 
-        const symbolInput = document.getElementById('symbolInput').value || 'NQ';
-        console.log(`Using symbol: ${symbolInput}`);
+        console.log(`üî•üî•üî• CRITICAL DEBUG: Reached end of STEP 2 try-catch block`);
+        console.log(`üî•üî•üî• symbolInput = "${symbolInput}"`);
+        console.log(`üî•üî•üî• About to proceed to STEP 3...`);
 
+        console.log(`üìç AUTOTRADE STEP 3: Processing symbol data...`);
         // Get root symbol (e.g., 'NQH5' -> 'NQ')
         const rootSymbol = symbolInput.replace(/[A-Z]\d+$/, '');
-        console.log(`Root symbol: ${rootSymbol}`);
+        console.log(`  Input symbol: "${symbolInput}"`);
+        console.log(`  Root symbol extracted: "${rootSymbol}"`);
 
         // Get tick size and default values from dictionary or fallback
-        const symbolData = futuresTickData[rootSymbol];
+        console.log(`üìç AUTOTRADE STEP 4: Looking up symbol configuration...`);
+        const symbolData = window.futuresTickData[rootSymbol];
+        if (symbolData) {
+            console.log(`  ‚úÖ Found symbol data for ${rootSymbol}:`, symbolData);
+        } else {
+            console.log(`  ‚ö†Ô∏è No symbol data found for ${rootSymbol}, will use fallbacks`);
+        }
 
         // Keep track of the last symbol to handle symbol changes
-        if (rootSymbol !== autoTrade.lastRootSymbol) {
-           document.getElementById('tickInput').value = symbolData?.tickSize ?? '';
+        const tickInputElement = document.getElementById('tickInput');
+        if (rootSymbol !== autoTrade.lastRootSymbol && tickInputElement) {
+           tickInputElement.value = symbolData?.tickSize ?? '';
         }
         autoTrade.lastRootSymbol = rootSymbol;
         const tickSize = (symbolData && typeof symbolData.tickSize === 'number')
                ? symbolData.tickSize
-               : parseFloat(document.getElementById('tickInput').value) || _tickSize;
+               : parseFloat(tickInputElement?.value) || _tickSize;
 
-        // right after tickSize is determined
-        tickInput.value = tickSize;           // shows the real value
-        localStorage.setItem('bracketTrade_tick', tickSize);
+        // right after tickSize is determined - only if UI element exists
+        if (tickInputElement) {
+            tickInputElement.value = tickSize;           // shows the real value
+            localStorage.setItem('bracketTrade_tick', tickSize);
+        }
 
         // Use provided values or defaults from dictionary or UI
+        const slInputElement = document.getElementById('slInput');
         const actualStopLossTicks = stopLossTicks ||
                                    symbolData?.defaultSL ||
-                                   parseInt(document.getElementById('slInput').value) ||
+                                   parseInt(slInputElement?.value) ||
                                    40;
 
+        const tpInputElement = document.getElementById('tpInput');
         const actualTakeProfitTicks = takeProfitTicks ||
                                      symbolData?.defaultTP ||
-                                     parseInt(document.getElementById('tpInput').value) ||
+                                     parseInt(tpInputElement?.value) ||
                                      100;
 
         const from = symbolData?.tickSize ? 'dictionary'
-          : document.getElementById('tickInput').value ? 'input field'
+          : tickInputElement?.value ? 'input field'
           : 'default parameter';
         console.log(`Using tick size ${tickSize} (from ${from})`);
-        console.log(`Using SL: ${actualStopLossTicks} ticks, TP: ${actualTakeProfitTicks} ticks`);
+        console.log(`  Final TP/SL values: SL=${actualStopLossTicks} ticks, TP=${actualTakeProfitTicks} ticks`);
 
-        console.log(`Getting market data for ${symbolInput}`);
+        console.log(`üìç AUTOTRADE STEP 6: Getting market data...`);
+        console.log(`  Calling getMarketData("${symbolInput}")`);
         const marketData = getMarketData(symbolInput);
         if (!marketData) {
-            console.error(`No market data for ${symbolInput}`);
+            console.error(`‚ùå AUTOTRADE FAILED: No market data available for ${symbolInput}`);
+            console.error(`  This usually means the symbol is not found in the trading interface`);
+            console.error(`  Check that the symbol exists in the quoteboard/market data table`);
             return;
         }
-        console.log('Market data:', marketData);
+        console.log(`  ‚úÖ Market data retrieved successfully:`, marketData);
+        console.log(`    Symbol: ${marketData.symbol}`);
+        console.log(`    Bid: ${marketData.bidPrice}`);
+        console.log(`    Offer: ${marketData.offerPrice}`);
+
+        console.log(`üìç AUTOTRADE STEP 7: Checking scale-in mode...`);
+        // Check if scale-in is enabled (skip this check if we're already processing a scale order)
+        const scaleCheckbox = document.getElementById('scaleInCheckbox');
+        const scaleInEnabled = !isScaleOrder && scaleCheckbox?.checked;
+        console.log(`  Scale-in checkbox element: ${scaleCheckbox ? 'FOUND' : 'NOT FOUND'}`);
+        console.log(`  Scale-in checkbox checked: ${scaleCheckbox?.checked}`);
+        console.log(`  Is scale order: ${isScaleOrder}`);
+        console.log(`  Final scale-in enabled: ${scaleInEnabled}`);
+        
+        if (scaleInEnabled) {
+            console.log(`üîÄ SCALE-IN MODE DETECTED - Delegating to auto_trade_scale function`);
+            
+            // Get scale parameters
+            console.log(`üìç SCALE-IN STEP 1: Getting scale parameters...`);
+            const scaleLevels = parseInt(document.getElementById('scaleLevelsInput')?.value || '4');
+            const scaleSpacing = parseInt(document.getElementById('scaleSpacingInput')?.value || '20');
+            
+            console.log(`  Scale levels: ${scaleLevels}`);
+            console.log(`  Scale spacing: ${scaleSpacing} ticks`);
+            console.log(`  Total quantity to split: ${quantity} contracts`);
+            
+            // Get entry price for scale calculation
+            const entryPriceInput = document.getElementById('entryPriceInput');
+            const customEntryPrice = entryPriceInput && entryPriceInput.value ? parseFloat(entryPriceInput.value) : null;
+            const entryPrice = customEntryPrice || parseFloat(action === 'Buy' ? marketData.offerPrice : marketData.bidPrice);
+            
+            // Calculate scale orders using backend logic
+            const scaleOrdersData = {
+                symbol: inputSymbol,
+                quantity: quantity,
+                action: action,
+                entry_price: customEntryPrice, // null for market orders
+                scale_levels: scaleLevels,
+                scale_ticks: scaleSpacing,
+                tick_size: tickSize
+            };
+            
+            console.log('Calculating scale orders with data:', scaleOrdersData);
+            
+            // Calculate scale orders (mimic backend calculation)
+            const scaleOrders = [];
+            const qtyPerLevel = Math.floor(quantity / scaleLevels);
+            const remainingQty = quantity % scaleLevels;
+            
+            for (let i = 0; i < scaleLevels; i++) {
+                const levelQty = qtyPerLevel + (i < remainingQty ? 1 : 0);
+                let levelPrice = null;
+                
+                if (customEntryPrice !== null) {
+                    // For limit/stop orders, calculate scaled entry prices
+                    const priceOffset = i * scaleSpacing * tickSize;
+                    // For both Buy and Sell: scale down from entry price
+                    // This creates orders at: entry, entry-20, entry-40, entry-60, etc.
+                    levelPrice = entryPrice - priceOffset;
+                }
+                
+                scaleOrders.push({
+                    quantity: levelQty,
+                    entry_price: levelPrice
+                });
+            }
+            
+            console.log(`üìç SCALE-IN STEP 3: Generated ${scaleOrders.length} scale orders:`, scaleOrders);
+            
+            // Call auto_trade_scale with calculated orders
+            console.log(`üìç SCALE-IN STEP 4: Calling auto_trade_scale function...`);
+            console.log(`  Parameters: auto_trade_scale("${inputSymbol}", scaleOrders, "${action}", ${actualTakeProfitTicks}, ${actualStopLossTicks}, ${tickSize})`);
+            auto_trade_scale(inputSymbol, scaleOrders, action, actualTakeProfitTicks, actualStopLossTicks, tickSize);
+            console.log(`üîÄ AUTOTRADE DELEGATED TO SCALE-IN - Exiting autoTrade function`);
+            return; // Exit early, scale handling is complete
+        }
 
-        // Check if an entry price was provided
-        const entryPriceInput = document.getElementById('entryPriceInput');
-        const customEntryPrice = entryPriceInput && entryPriceInput.value ? parseFloat(entryPriceInput.value) : null;
+        // Continue with single order logic if scale-in is disabled
+        console.log(`üìç AUTOTRADE STEP 8: Scale-in disabled, proceeding with single order logic...`);
+
+        // Check if an entry price was provided - prioritize explicit parameter over UI field
+        let customEntryPrice = null;
+        if (explicitEntryPrice !== null) {
+            console.log(`üî• USING EXPLICIT ENTRY PRICE: ${explicitEntryPrice}`);
+            customEntryPrice = parseFloat(explicitEntryPrice);
+        } else {
+            const entryPriceInput = document.getElementById('entryPriceInput');
+            customEntryPrice = entryPriceInput && entryPriceInput.value ? parseFloat(entryPriceInput.value) : null;
+            console.log(`üî• USING UI ENTRY PRICE: ${customEntryPrice}`);
+        }
         
         // Determine market price (used when no entry price is specified or for SL/TP calculations)
         const marketPrice = parseFloat(action === 'Buy' ? marketData.offerPrice : marketData.bidPrice);
         console.log(`Market price: ${marketPrice} (${action === 'Buy' ? 'offer' : 'bid'} price)`);
         
         // Determine entry order type and price
+        console.log(`üî• REACHED ORDER TYPE DETERMINATION SECTION`);
+        console.log(`üî• Initial values: customEntryPrice=${customEntryPrice}, marketPrice=${marketPrice}, explicitOrderType=${explicitOrderType}`);
         let orderType = 'MARKET';
         let entryPrice = marketPrice;
         
         // Use explicit order type if provided, otherwise fall back to entry price logic
+        console.log(`üî• Checking explicitOrderType: ${explicitOrderType}`);
         if (explicitOrderType) {
+            console.log(`üî• EXPLICIT ORDER TYPE BRANCH`);
+        
             // Validate order type
             const validOrderTypes = ['MARKET', 'LIMIT', 'STOP', 'STOP LIMIT', 'TRL STOP', 'TRL STP LMT'];
             if (!validOrderTypes.includes(explicitOrderType)) {
@@ -1129,19 +1817,29 @@ function autoTrade(inputSymbol, quantity = 1, action = 'Buy', takeProfitTicks =
                 console.log(`Using market price: ${entryPrice} for ${orderType} order`);
             }
         } else if (customEntryPrice !== null) {
+            console.log(`üî• AUTO-DETECTION BRANCH REACHED!`);
             console.log(`Custom entry price provided: ${customEntryPrice}`);
+            console.log(`Market price: ${marketPrice}`);
+            console.log(`Action: ${action}`);
             entryPrice = customEntryPrice;
             
             // Determine if this should be a LIMIT or STOP order based on price comparison
+            console.log(`üî• STARTING AUTO-DETECTION LOGIC...`);
             if (action === 'Buy') {
                 // For Buy: LIMIT if entry below market, STOP if entry above market
+                console.log(`üî• Buy order: comparing ${customEntryPrice} < ${marketPrice}`);
                 orderType = customEntryPrice < marketPrice ? 'LIMIT' : 'STOP';
+                console.log(`üî• Buy result: ${customEntryPrice < marketPrice ? 'BELOW market ‚Üí LIMIT' : 'ABOVE market ‚Üí STOP'}`);
             } else {
                 // For Sell: LIMIT if entry above market, STOP if entry below market
+                console.log(`üî• Sell order: comparing ${customEntryPrice} > ${marketPrice}`);
                 orderType = customEntryPrice > marketPrice ? 'LIMIT' : 'STOP';
+                console.log(`üî• Sell result: ${customEntryPrice > marketPrice ? 'ABOVE market ‚Üí LIMIT' : 'BELOW market ‚Üí STOP'}`);
             }
-            console.log(`Order type determined to be: ${orderType}`);
+            console.log(`üî• Order type determined to be: ${orderType}`);
+            console.log(`üî• AUTO-DETECTION LOGIC COMPLETED!`);
         } else {
+            console.log(`üî• NO CUSTOM ENTRY PRICE - Market order branch`);
             console.log(`No custom entry price provided, using market order at ${marketPrice}`);
         }
 
@@ -1190,11 +1888,72 @@ function autoTrade(inputSymbol, quantity = 1, action = 'Buy', takeProfitTicks =
             orderType: orderType,
             entryPrice: orderType !== 'MARKET' ? entryPrice.toFixed(decimalPrecision) : null
         };
-        console.log('Trade data prepared:', tradeData);
+        console.log(`üìç AUTOTRADE STEP 9: Trade data prepared for submission:`, tradeData);
 
-        console.log('Submitting bracket orders');
-        return createBracketOrdersManual(tradeData).finally(() => {
-            const d = futuresTickData[rootSymbol];      // or rootSymbol
+        console.log(`üìç AUTOTRADE STEP 10: Calling createBracketOrdersManual...`);
+        console.log(`  This will handle the actual DOM manipulation and order submission`);
+        
+        try {
+            // Execute the trade and capture feedback
+            console.log(`üìç AUTOTRADE STEP 10: Executing bracket orders...`);
+            const bracketResult = await createBracketOrdersManual(tradeData);
+            console.log(`üìä Bracket execution result:`, bracketResult);
+            
+            // Check if we already have valid feedback from bracket execution
+            const hasFeedback = bracketResult && (
+                bracketResult.rejectionReason || 
+                (bracketResult.success && bracketResult.orders?.length > 0) ||
+                (bracketResult.success === 'partial' && bracketResult.partialFills?.length > 0) ||
+                bracketResult.error
+            );
+            
+            let orderResult;
+            if (hasFeedback) {
+                console.log(`üìç AUTOTRADE STEP 11: Using feedback from bracket execution (no waitForOrderFeedback needed)`);
+                orderResult = bracketResult;
+            } else {
+                console.log(`üìç AUTOTRADE STEP 11: No feedback from bracket execution - falling back to waitForOrderFeedback...`);
+                orderResult = await waitForOrderFeedback();
+            }
+            
+            // Log the result with enhanced partial fill reporting
+            console.log(`üìç AUTOTRADE STEP 12: Order verification complete`);
+            console.log(`  Success: ${orderResult.success}`);
+            console.log(`  Orders placed: ${orderResult.orders.length}`);
+            
+            // Enhanced partial fill reporting
+            if (orderResult.success === 'partial') {
+                console.log(`‚ö†Ô∏è PARTIAL FILLS DETECTED:`);
+                console.log(`  Total filled quantity: ${orderResult.totalFillQuantity || 0}`);
+                console.log(`  Number of partial fills: ${orderResult.partialFills?.length || 0}`);
+                if (orderResult.partialFills && orderResult.partialFills.length > 0) {
+                    orderResult.partialFills.forEach((fill, index) => {
+                        console.log(`    Fill ${index + 1}: ${fill.event} - Qty: ${fill.quantity} - Partial: ${fill.isPartial}`);
+                    });
+                }
+                console.log(`‚ö†Ô∏è NOTE: Some orders may require manual completion or cancellation`);
+            } else if (orderResult.isPartiallyFilled) {
+                console.log(`‚ö†Ô∏è Partial fill indicators found - check order status`);
+            }
+            
+            if (orderResult.error) {
+                console.log(`  Error: ${orderResult.error}`);
+            }
+            if (orderResult.rejectionReason) {
+                console.log(`  Rejection: ${orderResult.rejectionReason}`);
+            }
+            
+            return orderResult;
+            
+        } catch (error) {
+            console.error(`‚ùå AUTOTRADE ERROR: ${error.message}`);
+            return {
+                success: false,
+                error: error.message,
+                orders: []
+            };
+        } finally {
+            const d = window.futuresTickData[rootSymbol];      // or rootSymbol
             const slInput = document.getElementById('slInput');
             const tpInput = document.getElementById('tpInput');
             /*
@@ -1206,9 +1965,170 @@ function autoTrade(inputSymbol, quantity = 1, action = 'Buy', takeProfitTicks =
                 localStorage.setItem('bracketTrade_sl', d.defaultSL);
                 localStorage.setItem('bracketTrade_tp', d.defaultTP);
             }*/
-        });
-    }
-
+        }
+    }; // End of window.autoTrade function
+
+    // Scale order function to handle multiple entry levels
+    // Make function declaration safe for reinjection
+    window.auto_trade_scale = async function(symbol, scaleOrders, action = 'Buy', takeProfitTicks = null, stopLossTicks = null, tickSize = 0.25) {
+        console.log(`\nüö®üö®üö®üö®üö®üö®üö® AUTO_TRADE_SCALE FUNCTION CALLED! üö®üö®üö®üö®üö®üö®üö®`);
+        console.log(`üö®üö®üö® THIS IS THE SCALE FUNCTION - NOT autoTrade üö®üö®üö®`);
+        console.log(`\n=== AUTO_TRADE_SCALE DEBUG ===`);
+        console.log(`Called with parameters:`);
+        console.log(`  symbol: ${symbol}`);
+        console.log(`  scaleOrders:`, scaleOrders);
+        console.log(`  action: ${action}`);
+        console.log(`  takeProfitTicks: ${takeProfitTicks}`);
+        console.log(`  stopLossTicks: ${stopLossTicks}`);
+        console.log(`  tickSize: ${tickSize}`);
+        
+        // Validate inputs
+        if (!scaleOrders || !Array.isArray(scaleOrders) || scaleOrders.length === 0) {
+            console.error('ERROR: Invalid scale orders - empty or not an array');
+            console.error('scaleOrders value:', scaleOrders);
+            return {
+                success: false,
+                error: 'Invalid scale orders configuration',
+                orders: []
+            };
+        }
+        
+        console.log(`Scale orders array length: ${scaleOrders.length}`);
+        
+        // Validate each order
+        console.log(`Validating ${scaleOrders.length} scale orders:`);
+        for (let i = 0; i < scaleOrders.length; i++) {
+            const order = scaleOrders[i];
+            console.log(`  Order ${i+1}:`, order);
+            
+            if (!order || typeof order.quantity !== 'number' || order.quantity <= 0) {
+                console.error(`ERROR: Invalid scale order at index ${i}: invalid quantity`);
+                console.error(`Order details:`, order);
+                return {
+                    success: false,
+                    error: `Invalid quantity in scale order ${i + 1}`,
+                    orders: []
+                };
+            }
+            
+            console.log(`    ‚úì Valid: ${order.quantity} contracts @ ${order.entry_price || 'Market'}`);
+        }
+        
+        console.log(`All orders validated successfully`);
+        
+        // Execute each scale order with a delay between them
+        const delayBetweenOrders = 500; // 500ms between orders
+        const orderResults = [];
+        
+        // Show initial progress message in console instead of popup
+        console.log(`[SCALE] üìä Placing ${scaleOrders.length} scaled orders...`);
+        
+        async function placeNextOrder(orderIndex) {
+            console.log(`\n--- placeNextOrder() called ---`);
+            console.log(`Current orderIndex: ${orderIndex}, Total orders: ${scaleOrders.length}`);
+            
+            if (orderIndex >= scaleOrders.length) {
+                const successfulOrders = orderResults.filter(r => r.success).length;
+                const failedOrders = orderResults.filter(r => !r.success).length;
+                
+                console.log(`=== SCALE ORDER EXECUTION COMPLETED ===`);
+                console.log(`Successful: ${successfulOrders}, Failed: ${failedOrders}`);
+                console.log(`=== END AUTO_TRADE_SCALE DEBUG ===`);
+                
+                // Show completion message in console instead of popup
+                if (failedOrders === 0) {
+                    console.log(`[SCALE] ‚úÖ ${successfulOrders} scale orders placed successfully`);
+                } else if (successfulOrders > 0) {
+                    console.log(`[SCALE] ‚ö†Ô∏è Scale orders completed: ${successfulOrders} successful, ${failedOrders} failed.`);
+                } else {
+                    console.log(`[SCALE] ‚ùå All ${failedOrders} scale orders failed.`);
+                }
+                
+                return {
+                    success: failedOrders === 0,
+                    orders: orderResults,
+                    summary: {
+                        total: scaleOrders.length,
+                        successful: successfulOrders,
+                        failed: failedOrders
+                    }
+                };
+            }
+            
+            const order = scaleOrders[orderIndex];
+            
+            // Show progress indicator 
+            console.log(`\nüîÑ Placing order ${orderIndex + 1} of ${scaleOrders.length}...`);
+            console.log(`  Order details:`, order);
+            console.log(`  Quantity: ${order.quantity}`);
+            console.log(`  Entry Price: ${order.entry_price}`);
+            
+            try {
+                console.log(`Calling autoTrade with:`);
+                console.log(`  symbol: ${symbol}`);
+                console.log(`  quantity: ${order.quantity}`);
+                console.log(`  action: ${action}`);
+                console.log(`  takeProfitTicks: ${takeProfitTicks}`);
+                console.log(`  stopLossTicks: ${stopLossTicks}`);
+                console.log(`  tickSize: ${tickSize}`);
+                console.log(`  explicitEntryPrice: ${order.entry_price} (passed directly)`);
+                
+                // Call autoTrade for this scale level
+                // IMPORTANT: Pass 0 for TP/SL to prevent bracket orders that interfere with scale levels
+                // We'll add TP/SL only to the final consolidated position if needed
+                // Pass isScaleOrder=true to prevent recursive scale-in checks
+                // Pass order.entry_price directly as explicitEntryPrice to bypass UI timing issues
+                const orderResult = await autoTrade(symbol, order.quantity, action, 0, 0, tickSize, null, true, order.entry_price);
+                
+                // Add scale order metadata to result
+                orderResult.scaleLevel = orderIndex + 1;
+                orderResult.requestedPrice = order.entry_price;
+                orderResult.requestedQuantity = order.quantity;
+                
+                orderResults.push(orderResult);
+                
+                if (orderResult.success) {
+                    console.log(`‚úÖ Order ${orderIndex + 1}/${scaleOrders.length} verified successfully (${order.quantity} contracts @ ${order.entry_price || 'Market'})`);
+                } else {
+                    console.log(`‚ùå Order ${orderIndex + 1}/${scaleOrders.length} failed: ${orderResult.error}`);
+                }
+                
+            } catch (error) {
+                console.error(`‚ùå ERROR placing scale order ${orderIndex + 1}/${scaleOrders.length}:`, error);
+                orderResults.push({
+                    success: false,
+                    error: error.message,
+                    scaleLevel: orderIndex + 1,
+                    requestedPrice: order.entry_price,
+                    requestedQuantity: order.quantity,
+                    orders: []
+                });
+            }
+            
+            // Wait before placing next order
+            if (orderIndex + 1 < scaleOrders.length) {
+                await new Promise(resolve => setTimeout(resolve, delayBetweenOrders));
+                return placeNextOrder(orderIndex + 1);
+            } else {
+                // This was the last order, return the results
+                const successfulOrders = orderResults.filter(r => r.success).length;
+                const failedOrders = orderResults.filter(r => !r.success).length;
+                
+                return {
+                    success: failedOrders === 0,
+                    orders: orderResults,
+                    summary: {
+                        total: scaleOrders.length,
+                        successful: successfulOrders,
+                        failed: failedOrders
+                    }
+                };
+            }
+        }
+        
+        // Start placing orders and return the promise
+        return placeNextOrder(0);
+    }; // End of window.auto_trade_scale function
 
     // helper ‚Äì builds the front-quarter code for any root (e.g. 'NQ' ‚Üí 'NQU5' or 'NQZ5' post-roll)
     function getFrontQuarter(root) {
@@ -1260,7 +2180,10 @@ function autoTrade(inputSymbol, quantity = 1, action = 'Buy', takeProfitTicks =
         return { symbol, bidPrice, offerPrice };
     }
     // --- FUTURES MONTH LETTERS (Jan-Dec) ---
-    const MONTH_CODES = ['F','G','H','J','K','M','N','Q','U','V','X','Z'];
+    // Use var to allow redeclaration on script reinjection
+    if (!window.MONTH_CODES) {
+        window.MONTH_CODES = ['F','G','H','J','K','M','N','Q','U','V','X','Z'];
+    }
 
     /**
  * Returns { letter, yearDigit } for the given date.
@@ -1268,7 +2191,7 @@ function autoTrade(inputSymbol, quantity = 1, action = 'Buy', takeProfitTicks =
  */
     function getMonthlyCode(date = new Date()) {
         console.log(`getMonthlyCode called with date: ${date.toISOString()}`);
-        const letter = MONTH_CODES[date.getUTCMonth()];      // 0-11 ‚Üí F ‚Ä¶ Z
+        const letter = window.MONTH_CODES[date.getUTCMonth()];      // 0-11 ‚Üí F ‚Ä¶ Z
         const yearDigit = (date.getUTCFullYear() % 10) + ''; // 2025 ‚Üí "5"
         console.log(`Calculated monthly code: letter=${letter}, yearDigit=${yearDigit}`);
         return { letter, yearDigit };
